# LiteXLoader - LXL插件开发文档

[<< 返回目录](README.md)

## ⛳  放在前面

欢迎加入LXL插件开发的大本营！从这里开始，你将逐步熟悉LXL插件开发的基本要素和流程。  

在开发插件的过程中，这里的众多文档无疑将成为你最好的帮手。  
首先熟悉他们，这将是你学习开发的过程中非常重要的一环。

<br>

## 💊 数据类型

众所周知，类型系统通常都是一个设计框架中比较关键的部分。  
因此，首先，你需要熟悉几种在使用 API 文档的过程中会频繁用到的数据类型。  
这些数据类型的名词会频繁出现在开发文档当中，请务必首先对他们足够熟悉。

### 通用数据类型约定

虽然脚本语言通常是弱类型的，不需要关注具体的数据类型，但由于LXL支持多种不同的脚本语言，为了方便对接API，下面定义一些通用的数据类型。

- `Null` - 空（未定义，不存在,无返回值等等）
- `Integer` - 整数
- `Float` - 浮点数（小数，实数）
- `String` - 字符串
- `ByteBuffer` - 字符数组（字节串，字符缓冲区）
- `Boolean` - 布尔型
- `Function` - 函数（方法）
- `Array` - 数组（列表）
- `Object` - 对象（映射，字典，表）
- `Player` - 玩家对象（详见PlayerAPI）
- `Entity` - 实体对象（详见EntityAPI）
- `Block` - 方块对象（详见BlockAPI）
- `Item` - 物品栏物品对象（详见ItemAPI）
- `Form` - 表单对象（详见GUIAPI）
- `DB` - 数据库对象（详见DBAPI）
- `IntPos` - 整数位置 坐标对象（详解在下）
- `FloatPos` - 实数位置 坐标对象（详解在下）

<br>

### 游戏元素对象

对于游戏元素的索引，在脚本中使用一个专门类型的变量来跟踪每一个游戏元素，并称其为「xx对象」，如「玩家对象」或者「方块对象」。你可以将其理解为元素的唯一标识符。   

<br>

### 位置坐标对象

在游戏中，数量众多的 API 都需要提供位置坐标。  
引擎采用 `IntPos` 和 `FloatPos` 类型的对象来标示坐标，称之为「位置坐标对象」。  

1. `IntPos`对象
   它的成员均为**整数**，多用来表示**方块坐标**等用整数表示的位置  
   对于某个 `IntPos` 类型变量 pos，有如下这些成员：  

   | 成员    | 含义   | 类型      |
   | ------- | ------ | --------- |
   | pos.x   | x 坐标 | `Integer` |
   | pos.y   | y 坐标 | `Integer` |
   | pos.z   | z 坐标 | `Integer` |
   | pos.dim | 维度   | `Integer` |

   其中，维度变量 pos.dim 的取值为：0 主世界，1 下界，2 末地  
   如果某种情况下维度无效，或者无法获取，你会发现`dim`的值为-1
   
   <br>
   
2. `FloatPos`对象
   它的成员均为**浮点数**，多用来表示**实体坐标**等用无法用整数表示的位置  
   对于某个 `FloatPos` 类型变量 pos，有如下这些成员：  

   | 成员    | 含义   | 类型      |
   | ------- | ------ | --------- |
   | pos.x   | x 坐标 | `Float`   |
   | pos.y   | y 坐标 | `Float`   |
   | pos.z   | z 坐标 | `Float`   |
   | pos.dim | 维度   | `Integer` |

   其中，维度变量 pos.dim 的取值为：0 主世界，1 下界，2 末地   
   如果某种情况下维度无效，或者无法获取，你会发现`dim`的值为-1

<br>

## 📌 API文档描述约定

众所周知，一个好的帮助文档自然离不开统一简洁的格式和一目了然的外观。  
因此，为了文档的格式统一和规范，接下来，需要统一规定一下LXL的帮助文档描述约定。

> 对于接下来你看到的所有API文档，都有这样的写作规则：

1. 关于文档中对 **函数参数类型** 的描述：  
   函数参数将按照 **参数名 : 参数类型** 格式描述  
   例如： cmd : `String` 表示一个**字符串**类型的变量cmd  
   如果参数类型出现`Array<...>`表示一个以<>内的变量为内容的数组 / 列表  

   

2. 关于文档中对 **可选参数** 的描述：  
   如果在参数描述处出现 `可选参数` 则代表你可以不传入这个参数。  
   当你不传入这个参数的时候，引擎将使用描述中给出的默认值。  
   在API接口参数中，可选参数会被[ ]框起来。  
   形如：`pl.tell(msg[,type])`，这里的`type`就属于可选参数
   
   
   
3. 关于文档中对 **函数别名** 的描述：  
   如果在API函数原型后出现 `xx环境下别名：...` 则表示在某种特定语言下当前 API 可以有**另一种**名字或者用法。  
   此时默认的函数名和特定的别名都可以使用，达到的效果**相同**。  
   如果你对这一段文字感到有点摸不着头脑，请后续到通用API文档中观察 `log` 函数 实例。

<br>

在熟悉上面这些基础设施之后，你可以开始逐步阅读其他各特定内容的文档了。  
如果碰到遗忘了的东西，可以多翻回来看看。

<br>

## 📜 插件开发小贴士

这里，有一些在开发插件的时候的建议，希望可以帮到你

- **不要重复**造轮子  
  在条件允许的情况下，尽量使用他人已经编写好的特定功能的库，而不是每个功能都自己编写一遍。这样，有利于生态的整合和发展。
- 尽量使用MC强大的**命令系统**  
  在编写插件，使用API时，也不应该忘记MC强大的命令系统。命令系统相比于插件API，有可移植性强、持续性强、官方支持等众多好处，多使用命令也可以大大降低加载器的维护难度。  
  如果可以使用命令系统来实现某种功能，就尽量配合使用命令实现。也欢迎你将相关功能推送进脚本基础库中，为更多开发者所用。
- 为**用户**思考  
  在设计界面和配置的时候，最好考虑到用户的感受。UI和命令等对外交互的内容最好可以做到清晰和一目了然。
- 多角度思考**创新**  
  除了向JE已有的优秀插件学习，也欢迎大家做出自己的创新。

[<< 返回目录](README.md)